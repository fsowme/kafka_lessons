- Брокер сообщений — это программное обеспечение, которое помогает сервисам обмениваться информацией

- Основные компоненты брокера сообщений:
    - Producer (отправитель) - создаёт и отправляет сообщения
    - Consumer (потребитель) - получает и обрабатывает сообщения
    - Subscription (подписка) - это способ, с помощью которого потребитель указывает,
        какие сообщения его интересуют. Потребитель может выбрать только нужные ему сообщения,
        а не обрабатывать все подряд. Он «подписывается» на определённые очереди сообщений и ждёт,
        когда туда поступят новые данные
    - Message (сообщение) — это данные, которые отправляет Producer и получает Consumer. Сообщение состоит из:
        1. Ключ (key) ― опциональный, используется для маршрутизации сообщения по разделам
        2. Значение (value) ― само сообщение, которое может быть объектом любого формата (JSON, строка и т. д.)
        3. Метаданные (metadata) ― дополнительная информация, например, временная метка (timestamp) и смещение (offset)

- Модели хранения данных - способ временного хранения данных (сообщений). Выделяют две модели хранения:
    - Очередь - Отправители добавляют сообщения в очередь. Когда информацию обработает потребитель,
        она сразу удаляется. Отправитель не беспокоится о том, когда сообщение будет обработано — потребитель заберёт
        его, когда будет готов
    - Журнал - это структура, где сообщения хранятся упорядоченно, как лог событий. Потребители могут читать сообщения
        несколько раз и с разной скоростью, сохраняя информацию о своём статусе. Сообщения не удаляются сразу после
        чтения, поэтому их можно обрабатывать повторно

- Журналы требуют больше ресурсов, использовать очереди проще

- Персистентность - Важное свойство модели передачи данных. Это способность сохранять сообщения для гарантии их
    доставки, даже если в системе случаются перебои

- Есть два способа передачи данных:
    - Pull-модель
    - Push-модель

- Pull-модель:
    - Суть: потребитель сам запрашивает сообщения у брокера
    - Сохранение сообщений: брокер хранит сообщения пока потребитель их не запросит и не подтвердит получение
    - Плюсы:
        - Можно регулировать частоту запросов
        - Удобно если у потребителя мало ресурсов или данные долго обрабатываются
    - Минусы:
        - Потребитель постоянно опрашивает брокер (если сообщений мало, это неэффективно)

- Push-модель:
    - Суть: брокер сам отправляет сообщения
    - Сохранение сообщений: в push-модели с персистентностью хранит сообщения пока они не будут доставлены потребителю,
        если потребитель загружен или упал, брокер ждет возможности их доставить
    - Плюсы:
        - Экономит ресурсы и ускоряет процесс передачи сообщений
    - Минусы:
        - Если сообщения приходит слишком быстро, может случиться перегрузка - потребитель не успеет все обработать
        - Если потребитель медленно обрабатывает сообщения, то они копятся, что нагружает брокер

- Что выбрать:
    - Pull - если хотим контролировать частоту обновлений и когда сообщения нерегулярны или не требуют мгновенной
    получения и обработки
    - Push - если данные должны поступать потребителю сразу по мере их создания, если задержки недопустимы

- Стили обмена сообщениями - способы, которыми системы обмениваются сообщениями через брокеров

- Основные паттерны (стили обмена сообщениями):
    - One-Way (однонаправленная связь) - отправитель просто отправляет сообщение, не ожидая ответа от получателя. Это
        простой и быстрый способ (отправка логов в систему логирования)
        Отправитель -> Брокер -> Получатель
    - Request-Reply (запрос-ответ) - отправитель отправляет сообщение и ждёт ответа (Система брони билетов отправляет
        запрос на поиск рейсов и получает ответ с результатами)
        Отправитель <-> Брокер <-> Получатель
    - Pub-Sub (издатель-подписчик) - сообщение от отправителя (Publisher) отправляется сразу нескольким получателям,
        которые подписаны на него. Удобно когда событие важно для разных сервисов (При покупке подписки в
            онлайн-кинотеатре сообщение получают сервиси авторизации, аналитики и бухгалтерии и обрабатывают это одно
            сообщение по-разному)
        Отправитель -> Брокер -> Получатель 1
                              -> Получатель 2
                              -> Получатель 3

- Гарантия доставки - брокеры гарантируют, что сообщение будет доставлено, есть три основных типа таких гарантий:
    - At Most Once (не более одного раза) - сообщение отправляется только один раз, если потеряется сообщение
        его не повторяют. Подходит для систем, где потеря не так критична (потеря одного клика на сайте из миллионов)
    - At Least Once (как минимум один раз) - сообщение будет доставлено минимум один раз, но может быть отправлено
        повторно в случае если с первого раза не получилось. Может привести к повторам сообщений и система должна
        уметь правильно обрабатывать повторяющиеся сообщения (Часто используется в системах мониторинга инфраструктуры,
        тк в них важен каждый инцидент)
    - Exactly Once (ровно один раз) - сообщение обрабатывается только один раз, даже если были попытки повторной
        отправки. Самый сложный вариант для реализации, но необходим в ситуациях, где критически важно и гарантированно
        получить данные, и избежать дубликатов (при выполнении платежей)

- Очередь недоставленных сообщений (DeadLetterQueue) - специальную очередь для сообщений, которые не удалось доставить
    или обработать. Сообщение из этой очереди можно проанализировать и исправить. Необходима для:
    - Обработка ошибок. Конфигурацию можно настроить так, что в DLQ будут поступать недоставленные или вызвавшие ошибки
        сообщения
    - Отложенная обработка. Сообщение в DLQ остаются, пока ошибка не будет исправлена
    - Мониторинг. Если кол-во сообщений в DLQ растёт, значит где-то в системе есть проблемы
    - Предотвращение потерь данных. Сообщения сохраняются и их можно повторно отправить или проанализировать

- Сравнение Kafka и RabbitMQ:
    - По моделе передачи сообщений:
        - Kafka - Pull-модель (Сервисы работают в своем ритме, регулируют частоту обновлений в зависимости от нагрузки,
            это полезно в системах, где важна способность масштабироваться)
        - RabbitMQ - Push-модель (Удобно в системах где необходимо обрабатывать сообщения сразу, но создает трудности,
            если потребители не успевают справляться с потоком сообщений)
    - Персистентность:
        - Kafka хранит сообщения в журнале (log) - персистентность по-умолчанию (Сервисы могу обращаться за данными
            спустя даже длительное время, данные удаляются спустя заданное время)
        - RabbitMQ поддерживает персистентность, но её нужно настраивать вручную для каждого сообщения или очереди
    - Гарантия доставки:
        - Kafka позволяет настроить "at least once" или "exactly once". Потребители читают в своём темпе
        - RabbitMQ поддерживает "at least once" и "возможно, только один раз" - доставка зависит от способностей
            потребителя обрабатывать сообщения вовремя
    - Производительность и масштабируемость:
        - Kafka подходит для работы с большими потоками данных и высокой нагрузкой, лучше справляется, где миллионы
            сообщений в секунду
        - RabbitMQ подходит для средней нагрузки, особенно когда нужны сложные маршрутизации и прямое взаимодействие
            меджу сервисами. При очень большой нагрузки может потребовать более сложной настройки и потреблять больше
            ресурсов
    - Природа системы и использование:
        - Kafka подходит для больших данных, аналитики, систем мониторинга, где важно сохранять последовательность
            сообщений и возможность их повторного чтения
        - RabbitMQ поддерживает сложные паттерны маршрутизации сообщений, часто используется где на первый план выходит
            скорость доставки, но не требуется длительное хранение сообщений

- Для дополнительного чтения:
    - https://practicum.yandex.ru/blog/broker-soobsheniy-apache-kafka/
    - https://zookeeper.apache.org/doc/r3.8.4/zookeeperOver.html
    - https://developer.confluent.io/learn/kraft/
    - https://yandex.cloud/ru/docs/message-queue/concepts/dlq
    - https://docs.confluent.io/kafka/design/delivery-semantics.html
